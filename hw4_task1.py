"""4. Определить, какое число в массиве встречается чаще всего."""

import random
import numpy as np
import timeit

list1 = [random.randint(0, 6) for i in range(10000)]


# Реализация 1 - проходим однократно по массиву, встречу каждого числа запоминаем в словарь.
def solution1(lst):
    counter = {}
    for el in lst:
        if el in counter:
            counter[el] += 1
        else:
            counter[el] = 1
    return sorted(counter.items(), key=lambda item: item[1], reverse=True)[0]


# Реализация 2: получаем уникальные числа массива, преобразовав его в множество. Дальше пользуемся функцией list.count()
def solution2(lst):
    unique = set(lst)
    max_elem = 0
    max_count = 0
    for item in unique:
        cnt = lst.count(item)
        if cnt > max_count:
            max_count = cnt
            max_elem = item
    return max_elem, max_count


# Реализация 3: преобразуем список в numpy-массив, дальше будем запускать для каждого
# уникального числа np.where и сравнивать по этому результату (аналогично предыдущему, но с numpy-реализацией списка)
def solution3(lst):
    lstn = np.asarray(lst)
    unique = set(lst)
    max_elem = 0
    max_count = 0
    for item in unique:
        cnt = np.where(lstn == item)[0]
        if len(cnt) > max_count:
            max_count = len(cnt)
            max_elem = item
    return max_elem, max_count


if __name__ == "__main__":
    for implementation in [solution1, solution2, solution3]:
        print(f"Время работы варианта {implementation.__name__}: "
              f"{timeit.timeit(stmt=lambda: implementation(list1), number=1000)}")

"""
Timeit выполняет каждую реализацию 1000 раз. В данном случае скорость выполнения будет зависеть не только
от числа элементов в массиве, но и от разнообразия этих элементов, так как второе и третье решение выполняют подсчет количества
уникальных элементов, преобразовав изначальный список в набор. Соответственно, чем меньше элементов в получившемся наборе, тем
быстрее будет выполнен подсчет.

Тест 1: 20 уникальных элементов в массиве, 1000 элементов - длина массива
list1 = [random.randint(0, 20) for i in range(1000)]
Результаты:
Время работы варианта solution1: 0.06438660000000002
Время работы варианта solution2: 0.18682189999999999
Время работы варианта solution3: 0.11132629999999999

Решение со словерем предсказуемо показывает лучший результат за счет однократного прохода по массиву. 
Решение с numpy работает быстрее обычного списка даже при небольшом разнообразии элементов, всего 20 штук. 

Тест 2: 100 уникальных элементов, 1000 элементов - длина массива (увеличили разнообразие).
Результаты:
Время работы варианта solution1: 0.0799858
Время работы варианта solution2: 0.8817145
Время работы варианта solution3: 0.2868609

Вариант 1 показал идентичное время - так и должно быть, т.к. он не зависит от разнообразия элементов. 
Второе и третье решение - зависят, поэтому время изменилось, но время решения 3 выросло в 2.57 раза, 
в то время как решение на основе list потребовало в 4.73 больше времени.

Попробуем увеличить количество элементов до 10000 при разнообразии 100:
list1 = [random.randint(0, 100) for i in range(10000)]
Результаты:
Время работы варианта solution1: 0.6654404
Время работы варианта solution2: 8.6489009
Время работы варианта solution3: 1.4605177000000005

Время решения 1 выросло линейно в 10 раз, как и предполагалось. Время решения на основе Python List выросло также в 10 раз.
А вот время на основе numpy выросло всего в 5.1 раза. Это обусловлено тем, что библиотека numpy имеет специализированную
реализацию, позволяющую эффективно работать с массивами. 

Попробуем снизить разнообразие. Возможно, в этом случае второе или третье решение окажутся быстрее.
list1 = [random.randint(0, 6) for i in range(10000)]
Результаты:
Время работы варианта solution1: 0.8160015999999999
Время работы варианта solution2: 0.7558677
Время работы варианта solution3: 0.7906732999999999

Действительно, решение на основе поиска количества уникальных элементов через методы класса List или массива numpy может
быть эффективнее, если разнообразие элементов массива не превышает 7.
"""
